/*-----------------------------------------------------------------------------
This source file is part of Sonetto RPG Engine.

Copyright (C) 2007,2008 Arthur Carvalho de Souza Lima, Guilherme Prá Vieira


Sonetto RPG Engine is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Sonetto RPG Engine is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this library; if not, write to the Free Software Foundation,
Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA or go to
http://www.gnu.org/copyleft/lesser.txt
-----------------------------------------------------------------------------*/

#include <sstream>
#include <wx/app.h>
#include <wx/timer.h>
#include <wx/msgdlg.h>
#include "ConfigApp.h"
#include "ConfigWindowImpl.h"

using namespace std;

namespace ConfigApplication {
    BEGIN_EVENT_TABLE(ConfigWindowImpl,ConfigWindow)
        EVT_TIMER(-1,ConfigWindowImpl::onTimerEvent)
    END_EVENT_TABLE()

    ConfigWindowImpl::ConfigWindowImpl(wxWindow* parent,ConfigApp *app) :
            ConfigWindow(parent) {
        // Keep a pointer to the application core(ConfigApp)
        mApp = app;

        // Create and start a low-timed timer
        // Events generated by it will be place for
        // ALHandler to update its state (i.e. generate
        // input events for KeyListener and JoyStickListener)
        mTimer = new wxTimer(this);
        mTimer->Start(50);
    }

    void ConfigWindowImpl::onChoiceD3D9Res( wxCommandEvent& event ) {
        // Fill D3D-related widgets again
        // Needed for FSAA level enumeration
        // See: D3DHandler::D3DHandler() remarks
        mApp->getD3DHandler()->fillWindow(this);
    }

    void ConfigWindowImpl::onCheckD3D9FullScreen( wxCommandEvent& event ) {
        // Fill D3D-related widgets again
        // Needed for FSAA level enumeration
        // See: D3DHandler::D3DHandler() remarks
        mApp->getD3DHandler()->fillWindow(this);
    }

    void ConfigWindowImpl::onTimerEvent( wxTimerEvent& event ) {
        mApp->getOISHandler()->update(this);
    }

    void ConfigWindowImpl::onDeviceChoice(wxCommandEvent& event) {
        wxWindowList  tabChildren;
        wxChoice     *devices = static_cast<wxChoice *>(event.GetEventObject());
        wxWindow     *iter    = NULL;

        // This method must get rid of buttons assigned to
        // joysticks when the device gets changed to a
        // keyboard-only input option (Selection number zero in
        // choicebox)
        // If the change is made to another joystick, we should
        // leave everything as is. That's what this condition does
        if(devices->GetSelection() > 0)
            return;

        // Based on the device choicebox, iterates back parents until
        // a player tab is found, where the cleaning takes place
        iter = devices->GetParent();
        while(iter->GetId() != ConfigWindow::ID_PLAYER_TAB) {
            iter = iter->GetParent();

            // If we have iterated all windows and such player tab was not found
            // an assertion error will occur
            assert(iter && "An input device choicebox must be within an ID_PLAYER_TAB");
        }

        // Gets player tab's children list and iterates through it
        tabChildren = iter->GetChildren();
        for(size_t i = 0;i < tabChildren.size();++i) {
            // If we find a button configuration text control...
            if(tabChildren[i]->GetId() >= ConfigWindow::ID_AXIS_LH1  &&
               tabChildren[i]->GetId() <= ConfigWindow::ID_BTN_DLEFT    ) {
                istringstream str;
                wxTextCtrl *btn = static_cast<wxTextCtrl *>(tabChildren[i]);

                // And if the configured button's text does not begin with
                // "KEY", that is, if it is not assigned to the keyboard,
                // it is changed to "Unused"
                str.str(btn->GetValue().Left(3).c_str());
                if(str.str() != "KEY")
                    btn->SetValue(wxT("Unused"));
            }
        }
    }

    void ConfigWindowImpl::OnClickApply( wxCommandEvent& event ) {
        // Alert failures
        if(!mApp->Save()) {
            wxMessageBox(wxT("Configuration file could not be saved. The file may be in use or is write-protected."),
                         wxT("Config save"),wxOK|wxICON_EXCLAMATION);
        }
    }

    void ConfigWindowImpl::OnClickCancel( wxCommandEvent& event ) {
        // Destroys window
        // Even after a call for wxWindow::Destroy(), however, one cannot
        // ensure whether the window have really closed. Frames and dialogs
        // are queued for destruction by wxWidgets, and will be so when
        // every of its pending events have been processed.
        if (!Destroy())
            printf("Frame queued for destruction.\n");
    }

    void ConfigWindowImpl::OnClickOk( wxCommandEvent& event ) {
        // Alert failures
        if(!mApp->Save()) {
            int a = wxMessageBox(wxT("Configuration file could not be saved. The file may be in use or is write-"
                                     "protected.\n\nAre you sure you want to exit without saving?"),
                                     wxT("Config save"),wxYES_NO|wxICON_EXCLAMATION);

            // If the user choose not to close the window, return without closing
            if(a == wxNO)
                return;
        }

        // Close the window
        Close(true);
    }
} // namespace
